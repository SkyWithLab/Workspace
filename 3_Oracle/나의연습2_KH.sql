--사용자 (USER) 테이블 만들기(회원가입 / 로그인에 필요)

CREATE TABLE USERS (
    USER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, --고유 회원번호, 자동증가 PK
    USERNAME VARCHAR2(50) NOT NULL, --회원이름(50자 제한 반드시입력)
    EMAIL VARCHAR2(100) UNIQUE NOT NULL,--이메일
    PASSWORD VARCHAR2(200) NOT NULL,
    CREATED_AT DATE DEFAULT SYSDATE
);


-- 제품 (PRODUCT) 테이블 /쇼핑몰에서 판매되는 제품
CREATE TABLE PRODUCT (
    PRODUCT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PRODUCT_NAME VARCHAR2(100) NOT NULL,
    DESCRIPTION VARCHAR2(500),
    CREATED_AT DATE DEFAULT SYSDATE
);


--재고 (INVENTORY)제품 가격 + 수량 관리
CREATE TABLE INVENTORY (
    INVENTORY_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PRODUCT_ID NUMBER NOT NULL,
    PRICE NUMBER NOT NULL,
    STOCK_QUANTITY NUMBER NOT NULL,
    UPDATED_AT DATE DEFAULT SYSDATE,
    CONSTRAINT FK_INVENTORY_PRODUCT FOREIGN KEY (PRODUCT_ID)
        REFERENCES PRODUCT(PRODUCT_ID)
);


--장바구니 (CART) 사용자가 담은 상품 관리
CREATE TABLE CART (
    CART_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USER_ID NUMBER NOT NULL,
    PRODUCT_ID NUMBER NOT NULL,
    QUANTITY NUMBER NOT NULL,
    CONSTRAINT FK_CART_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
    CONSTRAINT FK_CART_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID)
);


--주문 (ORDERS) 실제 결제된 주문 내역
CREATE TABLE ORDERS (
    ORDER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    USER_ID NUMBER NOT NULL,
    ORDER_DATE DATE DEFAULT SYSDATE,
    TOTAL_AMOUNT NUMBER NOT NULL,
    CONSTRAINT FK_ORDER_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID)
);


--주문 상세 (ORDER_ITEMS)주문 안에 포함된 제품들 (1:N 관계)
CREATE TABLE ORDER_ITEMS (
    ORDER_ITEM_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ORDER_ID NUMBER NOT NULL,
    PRODUCT_ID NUMBER NOT NULL,
    QUANTITY NUMBER NOT NULL,
    PRICE NUMBER NOT NULL,
    CONSTRAINT FK_ORDERITEM_ORDER FOREIGN KEY (ORDER_ID) REFERENCES ORDERS(ORDER_ID),
    CONSTRAINT FK_ORDERITEM_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID)
);


--ERD 관계 요약
--
--USERS ↔ CART (1:N, 유저는 여러 장바구니 아이템 담을 수 있음)
--PRODUCT ↔ INVENTORY (1:1, 제품 하나에 가격/재고 하나)
--PRODUCT ↔ CART (N:M, 카트는 여러 제품 담을 수 있음)
--USERS ↔ ORDERS (1:N, 한 유저는 여러 주문 가능)
--ORDERS ↔ ORDER_ITEMS ↔ PRODUCT (주문 안에 여러 제품 포함)

--"제품 등록 → 장바구니 → 주문 → 결제" 흐름이 전부 DB에 담깁











--------------------------------------------------------------------------------
--제품넣기 PRODUCT
INSERT INTO PRODUCT (PRODUCT_NAME, DESCRIPTION) --PRODUCT 테이블에 데이터를 넣겠다.
-- PRODUCT_NAME, DESCRIPTION 컬럼에 값을 넣을거임.
VALUES ('아이폰 15', 'Apple 최신 스마트폰');
--실제 값 첫번째 아이폰은 PRODUCT_NAME , 두번째 APPLE..은 DESCRIPTION에 들어감
--CREATED_AT -> 자동증가 IDENTITY 라서 알아서 번호를 줌 1부터~
--PRODUCT_ID -> 기본값 현재시간 자동 입력
-------------------------------------
INSERT INTO PRODUCT (PRODUCT_NAME, DESCRIPTION)
VALUES ('갤럭시 S24', 'Samsung 최신 스마트폰');
--두번째 제품 등록하기
--아이디는 2가되고 (두번째 제품이니까) 시간도 현재시간 자동입력됨
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--재고랑, 가격 넣기 INVENTORY(재고)
INSERT INTO INVENTORY (PRODUCT_ID, PRICE, STOCK_QUANTITY)
--INVENTORY 테이블에 데이터를 넣을거임.  제품번호 가격 재고수량만 넣음
VALUES (1, 1500000, 10);
--PRODUCT_ID, PRICE, STOCK_QUANTITY 순서대로 1, 1500000, 10임..
--INVENTORY_ID, UPDATED_AT 기본값으로 자동설정 되므로 제외
-------------------------------------
INSERT INTO INVENTORY (PRODUCT_ID, PRICE, STOCK_QUANTITY)
VALUES (2, 1200000, 5);
--위와 같음
--------------------------------------------------------------------------------
--JOIN 시키기 ,, 이유는 합쳐서 한눈에 보자는 뜻
SELECT P.PRODUCT_ID, P.PRODUCT_NAME, I.PRICE, I.STOCK_QUANTITY
--DESCRIPTION은 긴 설명이기 떄문에 가격,재고,이름만 들어가면 확인할때 없어도 됨
FROM PRODUCT P  --P는 너무길어서 별칭붙인거임 PRODUCT테이블을 (앞으로 P라고 부를게!)/가독성위해
JOIN INVENTORY I ON P.PRODUCT_ID = I.PRODUCT_ID;    --I도 별칭/ 
--FROM PRODUCT P//JOIN INVENTORY 둘이 JOIN해서 ON 같은 
--ON ->두 테이블의 키값이 같기때문에 
--두 테이블에서 같은숫자 1을가지면 그건 같은제품이라는 의미가 된다. 공통된 식별자(제품고유코드)덕분에 서로 연결할 수 있음.



--------------------------------------------------------------------------------



--위를 바탕으로 코딩테스트
--문제
--
--어떤 쇼핑몰 DB에는 다음과 같은 두 개의 테이블이 있습니다.
----------------PRODUCT 테이블----------------
--PRODUCT_ID	PRODUCT_NAME	DESCRIPTION
--1	아이폰 15	    Apple       최신 스마트폰
--2	갤럭시 S24	  Samsung       최신 스마트폰
--3	LG 그램	        LG             노트북
----------------INVENTORY 테이블----------------
--PRODUCT_ID	PRICE	STOCK_QUANTITY
--1	        1500000	        10
--2	        1200000	        5
--3	        1700000	        0
-----------------------------------------------
--요구사항
--
--두 테이블을 JOIN해서 제품 이름, 가격, 재고 수량을 함께 보여주는 SQL을 작성하시오.
--
--재고(STOCK_QUANTITY)가 1개 이상인 제품만 출력되도록 하시오.
-----------------------------------------------
--기대 출력 결과
--PRODUCT_NAME	PRICE	STOCK_QUANTITY
--아이폰 15	1500000	10
--갤럭시 S24	1200000	5
-----------------------------------------------
SELECT P.PRODUCT_NAME , I.PRICE, I.STOCK_QUANTITY 
FROM PRODUCT P
JOIN INVENTORY I ON P.PRODUCT_ID = I.PRODUCT_ID
WHERE I.STOCK_QUANTITY > 1;

컬럼 이름이 두 테이블에서 겹치지 않는 경우에는 별칭 생략 가능
 P. / I. 를 붙이는 이유 : PRODUCT.PRODUCT_ID, INVENTORY.PRODUCT_ID → 둘 다 PRODUCT_ID이런 상황에서 별칭 안 쓰면, DB가 “어느 테이블의 PRODUCT_ID냐?” 하고 헷갈림